/*	File:		MoreSCFTest.c	Contains:	Test program for all of MoreSCF.	Written by:	Quinn	Copyright:	Copyright (c) 2001 by Apple Computer, Inc., All Rights Reserved.	Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.				("Apple") in consideration of your agreement to the following terms, and your				use, installation, modification or redistribution of this Apple software				constitutes acceptance of these terms.  If you do not agree with these terms,				please do not use, install, modify or redistribute this Apple software.				In consideration of your agreement to abide by the following terms, and subject				to these terms, Apple grants you a personal, non-exclusive license, under Apple’s				copyrights in this original Apple software (the "Apple Software"), to use,				reproduce, modify and redistribute the Apple Software, with or without				modifications, in source and/or binary forms; provided that if you redistribute				the Apple Software in its entirety and without modifications, you must retain				this notice and the following text and disclaimers in all such redistributions of				the Apple Software.  Neither the name, trademarks, service marks or logos of				Apple Computer, Inc. may be used to endorse or promote products derived from the				Apple Software without specific prior written permission from Apple.  Except as				expressly stated in this notice, no other rights or licenses, express or implied,				are granted by Apple herein, including but not limited to any patent rights that				may be infringed by your derivative works or by other works in which the Apple				Software may be incorporated.				The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO				WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED				WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR				PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN				COMBINATION WITH YOUR PRODUCTS.				IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR				CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE				GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)				ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION				OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT				(INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN				ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.	Change History (most recent first):$Log: MoreSCFTest.c,v $Revision 1.2  2002/01/22 06:24:13  eskimo1Adapt to the new port scanner API. Also added some extra printfs when we get a comparison failure in TestCreateSet to make it easier to track down problems.Revision 1.1  2002/01/16 22:53:11  eskimo1First checked in.*//////////////////////////////////////////////////////////////////// MoreIsBetter Setup#include "MoreSetup.h"// System interfaces#include <CoreFoundation/CoreFoundation.h>#include <stdio.h>#include <unistd.h>// MIB Interfaces#include "MoreCFQ.h"#include "MoreSCFPortScanner.h"#include "MoreSCFCCLScanner.h"#include "MoreSCF.h"#include "MoreSCFDigest.h"#include "MoreSCFHelpers.h"/////////////////////////////////////////////////////////////////#pragma mark ***** Testsstatic Boolean gRunSilent = false;	// When this is set to true the test routines print nothing 	// during successful operation. This prevents a bunch of meaningless 	// output during the memory leak tests.extern void PrintPropertyList(CFPropertyListRef propList);	// Forward declaration.  Declared external for debugging purposes 	// in other modules.static void TestPortScanner(void)	// A simple test of the port scanner code.  This doesn't do a 	// lot of automated testing, but you can look at the results 	// and visually check them.{	OSStatus   	err;	CFArrayRef 	portArray;	CFIndex 	portCount;	CFIndex 	portIndex;	long		order;		if (!gRunSilent) {		fprintf(stderr, "TestPortScanner\n");	}	portArray = nil;		err = MoreSCCreatePortArray(&portArray);	if (err == noErr) {		portCount = CFArrayGetCount(portArray);		for (portIndex = 0; portIndex < portCount; portIndex++) {			CFDictionaryRef thisPort;						thisPort = (CFDictionaryRef) CFArrayGetValueAtIndex(portArray, portIndex);			if (!gRunSilent) {				fprintf(stderr, "Port %ld\n", portIndex);				fprintf(stderr, "  device   = ");				CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceDeviceName));				fprintf(stderr, "  name     = ");				CFShow(CFDictionaryGetValue(thisPort, kSCPropUserDefinedName));				fprintf(stderr, "  hardware = ");				CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceHardware));				fprintf(stderr, "  variant  = ");				CFShow(CFDictionaryGetValue(thisPort, kMoreSCPropNetInterfaceHardwareVariant));				fprintf(stderr, "  type     = ");				CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceType));				fprintf(stderr, "  subtype  = ");				CFShow(CFDictionaryGetValue(thisPort, kSCPropNetInterfaceSubType));				fprintf(stderr, "  MAC      = ");				CFShow(CFDictionaryGetValue(thisPort, kSCPropMACAddress));				(void) CFNumberGetValue((CFNumberRef) CFDictionaryGetValue(thisPort, CFSTR("SortOrder")), kCFNumberLongType, &order);				fprintf(stderr, "  sort     = %ld\n", order);			}		}	}		CFQRelease(portArray);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestCopySetsDict(void)	// A test of the MoreSCCopySetsDict routine, which proved key 	// in tracking down a reference count leak.{	OSStatus 		err;	CFDictionaryRef setsDict;	setsDict = nil;	err = MoreSCCopySetsDict(&setsDict);	CFQRelease(setsDict);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestSetEnumerationAndSwitch(void)	// A test of set enumeration and switching routines.{	OSStatus	err;	CFIndex  	setCount;	CFIndex	  	setIndex;	CFArrayRef	setIDs;	CFIndex		indexOfCurrentSet;		if (!gRunSilent) {		fprintf(stderr, "TestSetEnumerationAndSwitch\n");	}	setIDs = nil;		// Enumeration		err = MoreSCCopySetIDs(&setIDs, &indexOfCurrentSet);	if (err == noErr) {		setCount = CFArrayGetCount(setIDs);		for (setIndex = 0; setIndex < setCount; setIndex++) {			CFStringRef userVis;						userVis = nil;			err = MoreSCCopyUserVisibleNameOfSet( (CFStringRef) CFArrayGetValueAtIndex(setIDs, setIndex), &userVis);			if (err == noErr && !gRunSilent) {				fprintf(stderr, "#%ld %c ", setIndex, (setIndex == indexOfCurrentSet) ? '*' : ' ');				CFShow(userVis);				CFShow(CFArrayGetValueAtIndex(setIDs, setIndex));			}			CFQRelease(userVis);						if (err != noErr) {				break;			}		}	}	if (err == noErr) {		CFStringRef currentSetID;				currentSetID = nil;		err = MoreSCCopyCurrentSet(&currentSetID);		if (err == noErr && !gRunSilent) {			fprintf(stderr, "Current set ID is ");			CFShow(currentSetID);		}				CFQRelease(currentSetID);	}		// Switch		if (err == noErr) {		ItemCount newSet;				if (indexOfCurrentSet == 0) {			newSet = 1;		} else {			newSet = 0;		}		err = MoreSCSetCurrentSet( (CFStringRef) CFArrayGetValueAtIndex(setIDs, newSet));		if (err == noErr) {			err = MoreSCSetCurrentSet( (CFStringRef) CFArrayGetValueAtIndex(setIDs, indexOfCurrentSet));		}	}	CFQRelease(setIDs);	    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestDuplicateAndDeleteSet(void)	// A test of the set duplication and deleting routines.{	OSStatus err;	CFStringRef currentSetID;	CFStringRef newSetID;		if (!gRunSilent) {		fprintf(stderr, "TestDuplicateAndDeleteSet\n");	}	currentSetID = nil;	newSetID = nil;	err = MoreSCCopyCurrentSet(&currentSetID);	if (err == noErr) {		err = MoreSCDuplicateSet(currentSetID, CFSTR("Frog"), &newSetID);	}	if (err == noErr) {		if (!gRunSilent) {			fprintf(stderr, "New set ID is ");			CFShow(newSetID);		}				err = MoreSCDeleteSet(newSetID);	}		CFQRelease(currentSetID);	CFQRelease(newSetID);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestRenameSet(void)	// A test of the MoreSCRenameSet routine.{	OSStatus err;	CFStringRef currentSetID;	CFStringRef originalName;	CFStringRef newName;		if (!gRunSilent) {		fprintf(stderr, "TestRenameSet\n");	}	currentSetID = nil;	originalName = nil;	newName = nil;		err = MoreSCCopyCurrentSet(&currentSetID);	if (err == noErr) {		err = MoreSCCopyUserVisibleNameOfSet(currentSetID, &originalName);	}	if (err == noErr) {		err = MoreSCRenameSet(currentSetID, CFSTR("Frog"));	}	if (err == noErr) {		err = MoreSCCopyUserVisibleNameOfSet(currentSetID, &newName);	}	if (err == noErr) {		if ( ! CFEqual(newName, CFSTR("Frog")) ) {			fprintf(stderr, "••• newName isn't “Frog”\n");			CFShow(newName);		}		err = MoreSCRenameSet(currentSetID, originalName);	}	if (err == noErr) {		CFQRelease(newName);		newName = nil;				err = MoreSCCopyUserVisibleNameOfSet(currentSetID, &newName);	}	if (err == noErr) {		if ( ! CFEqual(newName, originalName) ) {			fprintf(stderr, "••• newName isn't the same as originalName\n");			CFShow(newName);		}	}		CFQRelease(currentSetID);	CFQRelease(originalName);	CFQRelease(newName);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestServiceEnumerate(void)	// A test of the service enumeration routines.{	OSStatus  err;	ItemCount serviceCount;	ItemCount serviceIndex;	CFArrayRef localServiceIDs;	CFArrayRef resolvedServiceIDs;	localServiceIDs = nil;	resolvedServiceIDs = nil;		err = MoreSCCopyServiceIDs(nil, &localServiceIDs, &resolvedServiceIDs);	if (err == noErr) {		serviceCount = CFArrayGetCount(localServiceIDs);		for (serviceIndex = 0; serviceIndex < serviceCount; serviceIndex++) {			CFStringRef userVisible;			Boolean     active;						userVisible = nil;			err = MoreSCCopyUserVisibleNameOfService(nil, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, serviceIndex), &userVisible);			if (err == noErr) {				err = MoreSCIsServiceActive(nil, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, serviceIndex), &active);			}			if (err == noErr && !gRunSilent) {				fprintf(stderr, "#%ld %c ", serviceIndex, (active) ? ' ' : 'X');				CFShow(userVisible);				CFShow(CFArrayGetValueAtIndex(localServiceIDs, serviceIndex));				CFShow(CFArrayGetValueAtIndex(resolvedServiceIDs, serviceIndex));			}						CFQRelease(userVisible);						if (err != noErr) {				break;			}		}	}	CFQRelease(localServiceIDs);	CFQRelease(resolvedServiceIDs);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestDuplicateAndDeleteService(void)	// A test of the service duplication and deleting routines.{	OSStatus 	err;	CFArrayRef  localServiceIDs;	CFStringRef newServiceID;		if (!gRunSilent) {		fprintf(stderr, "TestDuplicateAndDeleteService\n");	}		newServiceID = nil;	localServiceIDs = nil;	// Use nil for the set ID to indicate that we're operating on	// the current set.	//	// Can't use nil for a service ID, so we have to come up with 	// a valid service ID first.  We do this by choosing the first 	// service ID.		err = MoreSCCopyServiceIDs(nil, &localServiceIDs, nil);	if (err == noErr) {		MoreAssertQ( CFArrayGetCount(localServiceIDs) > 0 );		err = MoreSCDuplicateService(nil, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, 0), CFSTR("Frog"), &newServiceID);	}	if (err == noErr) {		if (!gRunSilent) {			fprintf(stderr, "New service ID is ");			CFShow(newServiceID);		}				err = MoreSCDeleteService(nil, newServiceID);	}	CFQRelease(localServiceIDs);	CFQRelease(newServiceID);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestRenameService(void)	// A test of the MoreSCRenameService routine.{	OSStatus 	err;	CFArrayRef  localServiceIDs;	CFStringRef originalName;	CFStringRef newName;	CFStringRef serviceZero;		if (!gRunSilent) {		fprintf(stderr, "TestRenameService\n");	}		localServiceIDs = nil;	originalName = nil;	newName = nil;	// Use nil for the set ID to indicate that we're operating on	// the current set.	//	// Can't use nil for a service ID, so we have to come up with 	// a valid service ID first.  We do this by choosing the first 	// service ID.		err = MoreSCCopyServiceIDs(nil, &localServiceIDs, nil);	if (err == noErr) {		MoreAssertQ( CFArrayGetCount(localServiceIDs) > 0 );		serviceZero = (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, 0);		err = MoreSCCopyUserVisibleNameOfService(nil, serviceZero, &originalName);	}	if (err == noErr) {		err = MoreSCRenameService(nil, serviceZero, CFSTR("Frog"));	}	if (err == noErr) {		err = MoreSCCopyUserVisibleNameOfService(nil, serviceZero, &newName);	}	if (err == noErr) {		if ( ! CFEqual(newName, CFSTR("Frog")) ) {			fprintf(stderr, "••• newName isn't “Frog”\n");			CFShow(newName);		}		err = MoreSCRenameService(nil, serviceZero, originalName);	}	if (err == noErr) {		CFQRelease(newName);		newName = nil;				err = MoreSCCopyUserVisibleNameOfService(nil, serviceZero, &newName);	}	if (err == noErr) {		if ( ! CFEqual(newName, originalName) ) {			fprintf(stderr, "••• newName isn't the same as originalName\n");			CFShow(newName);		}	}		CFQRelease(localServiceIDs);	CFQRelease(originalName);	CFQRelease(newName);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestEnumerateEntities(void)	// A test of the MoreSCCopyEntities routine.{	OSStatus 	err;	CFArrayRef  localServiceIDs;	ItemCount	entityCount;	ItemCount	entityIndex;	CFArrayRef  protocols;	CFArrayRef  values;		if (!gRunSilent) {		fprintf(stderr, "TestEnumerateEntities\n");	}	// Use nil for the set ID to indicate that we're operating on	// the current set.	//	// Can't use nil for a service ID, so we have to come up with 	// a valid service ID first.  We do this by choosing the first 	// service ID.		localServiceIDs = nil;	protocols = nil;	values = nil;		err = MoreSCCopyServiceIDs(nil, &localServiceIDs, nil);	if (err == noErr) {		MoreAssertQ(CFArrayGetCount(localServiceIDs) > 0);		err = MoreSCCopyEntities(nil, (CFStringRef) CFArrayGetValueAtIndex(localServiceIDs, 0), &protocols, &values);	}	if (err == noErr && !gRunSilent) {		entityCount = CFArrayGetCount(protocols);		for (entityIndex = 0; entityIndex < entityCount; entityIndex++) {			fprintf(stderr, "#%ld ", entityIndex);			CFShow(CFArrayGetValueAtIndex(protocols, entityIndex));			CFShow(CFArrayGetValueAtIndex(values,    entityIndex));		}	}	CFQRelease(localServiceIDs);	CFQRelease(protocols);	CFQRelease(values);	    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static OSStatus CompareServices(CFStringRef lhsSet, CFStringRef lhsService, 								CFStringRef rhsSet, CFStringRef rhsService)	// A service comparison routine used by the CompareSets routine.	// This is godawful code but it's only test code and I don't have time to 	// make it more elegant at this point.{	OSStatus    err;	CFStringRef lhsUserVisible;	CFStringRef rhsUserVisible;	Boolean     lhsActive;	Boolean     rhsActive;	CFStringRef lhsBSD;	CFStringRef rhsBSD;	CFArrayRef  lhsProtocols;	CFArrayRef  rhsProtocols;	CFArrayRef  lhsValues;	CFArrayRef  rhsValues;	CFDictionaryRef lhsDict;	CFDictionaryRef rhsDict;		lhsUserVisible = nil;	rhsUserVisible = nil;	lhsBSD = nil;	rhsBSD = nil;	lhsProtocols = nil;	rhsProtocols = nil;	lhsValues = nil;	rhsValues = nil;	lhsDict = nil;	rhsDict = nil;	#if 0		fprintf(stderr, "lhsSet, rhsSet, lhsService, rhsService = \n");		CFShow(lhsSet);		CFShow(rhsSet);		CFShow(lhsService);		CFShow(rhsService);	#endif		// User visible name		err = MoreSCCopyUserVisibleNameOfService(lhsSet, lhsService, &lhsUserVisible);	if (err == noErr) {		err = MoreSCCopyUserVisibleNameOfService(rhsSet, rhsService, &rhsUserVisible);	}	if (err == noErr) {		if ( ! CFEqual(lhsUserVisible, rhsUserVisible) ) {			fprintf(stderr, "••• User visible names don't match\n");			CFShow(lhsUserVisible);			CFShow(rhsUserVisible);			err = -1;		}	}		// Active flag		if (err == noErr) {		err = MoreSCIsServiceActive(lhsSet, lhsService, &lhsActive);	}	if (err == noErr) {		err = MoreSCIsServiceActive(rhsSet, rhsService, &rhsActive);	}	if (err == noErr) {		if ( lhsActive != rhsActive ) {			fprintf(stderr, "••• Active flags don't match\n");			err = -1;		}	}	// BSD name		if (err == noErr) {		err = MoreSCCopyBSDNameOfService(lhsSet, lhsService, &lhsBSD);	}	if (err == noErr) {		err = MoreSCCopyBSDNameOfService(rhsSet, rhsService, &rhsBSD);	}	if (err == noErr) {		if ( ! CFEqual(lhsBSD, rhsBSD) ) {			fprintf(stderr, "••• BSD names don't match\n");			CFShow(lhsBSD);			CFShow(rhsBSD);			err = -1;		}	}	// Entities in service		if (err == noErr) {		err = MoreSCCopyEntities(lhsSet, lhsService, &lhsProtocols, &lhsValues);	}	if (err == noErr) {		err = MoreSCCopyEntities(rhsSet, rhsService, &rhsProtocols, &rhsValues);	}	if (err == noErr) {		err = CFQDictionaryCreateWithArrayOfKeysAndValues(lhsProtocols, lhsValues, &lhsDict);	}	if (err == noErr) {		err = CFQDictionaryCreateWithArrayOfKeysAndValues(rhsProtocols, rhsValues, &rhsDict);	}	if (err == noErr) {		if ( ! CFEqual(lhsDict, rhsDict) ) {			fprintf(stderr, "••• Entities don't match\n");			PrintPropertyList(lhsDict);			PrintPropertyList(rhsDict);			err = -1;		}	}	CFQRelease(lhsUserVisible);	CFQRelease(rhsUserVisible);	CFQRelease(lhsBSD);	CFQRelease(rhsBSD);	CFQRelease(lhsProtocols);	CFQRelease(rhsProtocols);	CFQRelease(lhsValues);	CFQRelease(rhsValues);	CFQRelease(lhsDict);	CFQRelease(rhsDict);		return err;}static OSStatus CompareGlobalEntities(CFStringRef lhsSet, CFStringRef rhsSet)	// A routine to compare global entities, taking care to ignore 	// certain entities that aren't relevant.  This is used by the 	// CompareSets routine.	//	// This is godawful code but it's only test code and I don't have time to 	// make it more elegant at this point.{	OSStatus		err;	CFArrayRef  	lhsProtocols;	CFArrayRef  	rhsProtocols;	CFArrayRef  	lhsValues;	CFArrayRef  	rhsValues;	CFDictionaryRef lhsDict;	CFDictionaryRef rhsDict;	CFMutableDictionaryRef lhsMutableDict;	CFMutableDictionaryRef rhsMutableDict;	CFStringRef     serviceOrderPath[2];	lhsProtocols = nil;	rhsProtocols = nil;	lhsValues = nil;	rhsValues = nil;	lhsDict = nil;	rhsDict = nil;	lhsMutableDict = nil;	rhsMutableDict = nil;	// Create two mutable dictionaries, ones for the LHS entities and the 	// other for the RHS entities.		err = MoreSCCopyEntities(lhsSet, nil, &lhsProtocols, &lhsValues);	if (err == noErr) {		err = MoreSCCopyEntities(rhsSet, nil, &rhsProtocols, &rhsValues);	}	if (err == noErr) {		err = CFQDictionaryCreateWithArrayOfKeysAndValues(lhsProtocols, lhsValues, &lhsDict);	} 	if (err == noErr) {		err = CFQDictionaryCreateWithArrayOfKeysAndValues(rhsProtocols, rhsValues, &rhsDict);	}	if (err == noErr) {		lhsMutableDict = CFDictionaryCreateMutableCopy(nil, 0, lhsDict);		if (lhsMutableDict == nil) {			err = coreFoundationUnknownErr;		}	}	if (err == noErr) {		rhsMutableDict = CFDictionaryCreateMutableCopy(nil, 0, rhsDict);		if (rhsMutableDict == nil) {			err = coreFoundationUnknownErr;		}	}	// Remove the elementsl at "IPv4/ServiceOrder" because they will never 	// compare equal because they contain different service IDs.	serviceOrderPath[0] = kSCEntNetIPv4;	serviceOrderPath[1] = kSCPropNetServiceOrder;	if (err == noErr) {		err = CFQDictionaryRemoveValueAtPath(lhsMutableDict, (const void **) serviceOrderPath, 2);	}	if (err == noErr) {		err = CFQDictionaryRemoveValueAtPath(rhsMutableDict, (const void **) serviceOrderPath, 2);	}		// Now compare the dictionaries.		if (err == noErr) {		if ( ! CFEqual(lhsMutableDict, rhsMutableDict) ) {			fprintf(stderr, "••• Global entities don't match\n");			PrintPropertyList(lhsMutableDict);			PrintPropertyList(rhsMutableDict);			err = -1;		}	}		CFQRelease(lhsProtocols);	CFQRelease(rhsProtocols);	CFQRelease(lhsValues);	CFQRelease(rhsValues);	CFQRelease(lhsDict);	CFQRelease(rhsDict);	CFQRelease(lhsMutableDict);	CFQRelease(rhsMutableDict);		return err;}static OSStatus CompareSets(CFStringRef lhsSet, CFStringRef rhsSet)	// A routine to compare two sets to see if they're identical. 	// TestCreateSet uses this to check that the newly created set 	// was created correctly.{	OSStatus   err;	CFArrayRef lhsServices;	CFArrayRef rhsServices;	CFIndex    serviceCount;	CFIndex    serviceIndex;		// MoreSCCopyUserVisibleNameOfSet not called because 	// user visible name of sets will be different.		lhsServices = nil;	rhsServices = nil;		// Services within the set		err = MoreSCCopyServiceIDs(lhsSet, &lhsServices, nil);	if (err == noErr) {		err = MoreSCCopyServiceIDs(rhsSet, &rhsServices, nil);	}	if (err == noErr) {		if ( CFArrayGetCount(lhsServices) != CFArrayGetCount(rhsServices) ) {			fprintf(stderr, "••• Service counts not equal.\n");			fprintf(stderr, "%ld\n", CFArrayGetCount(lhsServices));			fprintf(stderr, "%ld\n", CFArrayGetCount(rhsServices));			err = -1;		}	}	if (err == noErr) {		serviceCount = CFArrayGetCount(lhsServices);				for (serviceIndex = 0; serviceIndex < serviceCount; serviceIndex++) {			err = CompareServices(lhsSet, (CFStringRef) CFArrayGetValueAtIndex(lhsServices, serviceIndex),								  rhsSet, (CFStringRef) CFArrayGetValueAtIndex(rhsServices, serviceIndex));			if (err != noErr) {				break;			}		}	}		// Global entities		if (err == noErr) {		err = CompareGlobalEntities(lhsSet, rhsSet);	}		CFQRelease(lhsServices);	CFQRelease(rhsServices);	return err;}static void TestCreateSet(void)	// A routine to test the set creation and deletion code. 	// It compares the newly created set against a set called 	// "DefaultLocationForMoreSCFTest" to ensure that the set 	// created by MoreSCF matches a set created by the control 	// panel.{	OSStatus 		err;	OSStatus 		err2;	CFStringRef		newSetID;	CFStringRef		templateSetID;		if (!gRunSilent) {		fprintf(stderr, "TestCreateSet\n");	}		newSetID = nil;	templateSetID = nil;	err = MoreSCFindSetByUserVisibleNameAndCopyID(CFSTR("DefaultLocationForMoreSCFTest"), &templateSetID);	if (err != noErr || templateSetID == nil) {		fprintf(stderr, "••• TestCreateSet requires that you create a default set named “DefaultLocationForMoreSCFTest” using the Network preferences panel.\n");	}	if (err == noErr) {		err = MoreSCNewSet(CFSTR("Frog"), &newSetID);	}	if (err == noErr) {		if (!gRunSilent) {			fprintf(stderr, "New set ID is ");			CFShow(newSetID);		}				err = CompareSets(newSetID, templateSetID);		err2 = MoreSCDeleteSet(newSetID);		if (err == noErr) {			err = err2;		}	}		CFQRelease(newSetID);	CFQRelease(templateSetID);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestISP(void)	// A routine to test the ISP support routines.{	OSStatus err;	CFStringRef setID;	CFStringRef setID2;	CFStringRef newSetID;		if (!gRunSilent) {		fprintf(stderr, "TestISP\n");	}	setID = nil;	setID2 = nil;	newSetID = nil;		err = MoreSCFindSetByUserVisibleNameAndCopyID(CFSTR("DefaultLocationForMoreSCFTest"), &setID);	if (err == noErr) {		if (setID == nil) {			fprintf(stderr, "••• Couldn't find the set “DefaultLocationForMoreSCFTest”\n");		} else if (!gRunSilent) {			fprintf(stderr, "Set ID for “DefaultLocationForMoreSCFTest” is ");			CFShow(setID);		}	}	if (err == noErr) {		err = MoreSCFindSetByUserVisibleNameAndCopyID(CFSTR("Who would give a set such a silly name"), &setID2);		if (setID2 != nil) {			fprintf(stderr, "••• Found set that shouldn't exist\n");		}	}	if (err == noErr) {		MoreSCPPPDigest ppp;				BlockZero(&ppp, sizeof(ppp));		ppp.active            = true;		ppp.authName          = CFSTR("Quinn");		ppp.authPassword      = CFSTR("eskimo");		ppp.commRemoteAddress = CFSTR("123 4567");		err = MoreSCMakeNewDialupSet(nil, CFSTR("Frog"), nil, &ppp, nil, nil, &newSetID);	}	if (err == noErr) {		err = MoreSCDeleteSet(newSetID);	}		CFQRelease(setID);	CFQRelease(setID2);	CFQRelease(newSetID);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}static void TestAppleTalk(void)	// A routine to test the AppleTalk on/off routines.{	OSStatus 	err;	Boolean  	originalState;	Boolean		newState;	if (!gRunSilent) {		fprintf(stderr, "TestAppleTalk\n");	}			err = MoreSCIsAppleTalkActive(nil, &originalState);	if (err == noErr && !gRunSilent) {		fprintf(stderr, "AppleTalk is %s.\n", originalState ? "active" : "inactive");	}	if (err == noErr) {		err = MoreSCSetAppleTalkActive(nil, !originalState);	}	if (err == noErr) {		err = MoreSCIsAppleTalkActive(nil, &newState);	}	if (err == noErr) {		if (!gRunSilent) {			fprintf(stderr, "AppleTalk is now %s.\n", newState ? "active" : "inactive");		}		if (newState != !originalState) {			fprintf(stderr, "••• Failed to change state.\n");		}	}	if (err == noErr) {		err = MoreSCSetAppleTalkActive(nil, originalState);	}	if (err == noErr) {		err = MoreSCIsAppleTalkActive(nil, &newState);	}	if (err == noErr) {		if (!gRunSilent) {			fprintf(stderr, "AppleTalk is now %s.\n", newState ? "active" : "inactive");		}		if (newState != originalState) {			fprintf(stderr, "••• Failed to restore state.\n");		}	}    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }}/////////////////////////////////////////////////////////////////#pragma mark ***** Leaking Testingstatic pascal void PrintPropertyListCallback(CFTypeRef key, CFTypeRef node, void *context)	// A callback routine used by PrintPropertyList to print 	// a property list in a nicely formatted way.{	#pragma unused(key)	int i;	int depth;		depth = (int)context;		for (i = 0; i < depth; i++) {		fprintf(stderr, "  ");	}	{		CFStringRef fullDesc;		CFStringRef typeDesc;		CFStringRef valueDesc;		fullDesc = nil;				typeDesc = CFCopyTypeIDDescription(CFGetTypeID(node));		valueDesc = nil;		if ( CFQPropertyListIsLeaf(node) ) {			if ( CFGetTypeID(node) == CFStringGetTypeID() ) {				valueDesc = (CFStringRef) CFRetain(node);			} else if ( CFGetTypeID(node) == CFNumberGetTypeID() ) {				valueDesc = (CFStringRef) CFRetain(node);			} else {				valueDesc = CFCopyDescription(node);			}			fullDesc = CFStringCreateWithFormat(nil, nil, CFSTR("%@ : %@ [%d] = %@"), key, typeDesc, CFGetRetainCount(node), valueDesc);		} else {			fullDesc = CFStringCreateWithFormat(nil, nil, CFSTR("%@ : %@ [%d]"), key, typeDesc, CFGetRetainCount(node));		}		CFShow(fullDesc);		CFQRelease(fullDesc);		CFQRelease(valueDesc);		CFQRelease(typeDesc);	}	if ( ! CFQPropertyListIsLeaf(node) ) {		CFQPropertyListShallowApplyFunction(node, PrintPropertyListCallback, (void *) (depth + 1) );	}}extern void PrintPropertyList(CFPropertyListRef propList)	// This routine prints a CFPropertyList in a nicely formatted way.{	PrintPropertyListCallback(CFSTR("ROOT"), propList, (void *) 0);}static pascal void RefCounter(CFTypeRef node, void *context)	// A callback routine that adds node's reference count 	// to a global total.  Used by TotalAllRefCounts.{	(*((SInt32 *)context)) += CFGetRetainCount(node);}static SInt32 TotalAllRefCounts(SCPreferencesRef prefsRef, CFArrayRef allKeys)	// Given a connection to the SCF preferences database and an array 	// of preference keys, this routine calculates the total of all 	// of the reference counts of all of the nodes in all of the SCF 	// preferences.  I use this routine to check for reference count leaks 	// in my use of the SCF preferences database.{	CFIndex keyCount;	CFIndex keyIndex;	SInt32	result;		result = 0;	keyCount = CFArrayGetCount(allKeys);	for (keyIndex = 0; keyIndex < keyCount; keyIndex++) {		CFPropertyListRef thisPref;				thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));	// C++ requires cast		CFQPropertyListDeepApplyFunction(thisPref, RefCounter, (void *) &result );	}	return result;}static void PrintAllPreferences(SCPreferencesRef prefsRef, CFArrayRef allKeys)	// This routine prints all of the preferences in the SCF preferences 	// database.  I use it during debugging.{	CFIndex keyCount;	CFIndex keyIndex;		keyCount = CFArrayGetCount(allKeys);	for (keyIndex = 0; keyIndex < keyCount; keyIndex++) {		CFPropertyListRef thisPref;				thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));	// C++ requires cast		PrintPropertyList(thisPref);	}}typedef void (*TestFunc)(void);static void LeakTest(const char *testName, TestFunc tester)	// Given a test name and a pointer to a test function, 	// this routine calls the test function repeatedly to check 	// for SCF preferences reference count leaks.{	OSStatus 			err;	SCPreferencesRef 	prefsRef;	CFArrayRef 			allKeys;	int					i;	SInt32				startCount;	SInt32				endCount;		fprintf(stderr, "LeakTest(%s)\n", testName);		// This is kinda cheesy.  We need to use the same SCPreferencesRef 	// that MoreSCF uses because otherwise we can't see the reference 	// count changes done by MoreSCF.  Ideally, we wouldn't want to run 	// within a MoreSCOpen/MoreSCClose pair because then our changes 	// aren't necessarily being committed to the database.  However, 	// given the current MoreSCF architecture, where the SCPreferenceRef 	// is only valid inside the MoreSCOpen/MoreSCClose pair, that's 	// exactly what we have to do.	// Make sure that the test doesn't print stuff because we'll be 	// calling it repeatedly.		gRunSilent = true;		allKeys = nil;		err = MoreSCOpen(false, false);	if (err == noErr) {		prefsRef = MoreSCGetSCPreferencesRef();	}	// Now get a copy of the array of all keys in the database.  	// We make this copy using CFPropertyListCreateDeepCopy so we 	// know that it's completely independent of the SCF.		if (err == noErr) {		CFArrayRef allKeysOrig;				allKeysOrig = nil;		allKeysOrig = SCPreferencesCopyKeyList(prefsRef);		if (allKeysOrig == nil) {			err = SCError();		}		if (err == noErr) {			allKeys = (CFArrayRef) CFPropertyListCreateDeepCopy(nil, allKeysOrig, kCFPropertyListMutableContainersAndLeaves);	// C++ requires cast			if (allKeys == nil) {				err = coreFoundationUnknownErr;			}		}				CFQRelease(allKeysOrig);	}	// Now do the reference counting test.  Call the tester function	// a few times to allow the refcounts to stabilise.  Then get 	// a summ of all the nodes in all of the keys in SCF.  Then 	// run the test a 10 more times and get another count.  If 	// the counts are different, we're in trouble.		if (err == noErr) {		for (i = 0; i < 3; i++) {			tester();		}				startCount = TotalAllRefCounts(prefsRef, allKeys);				for (i = 0; i < 10; i++) {			tester();		}				endCount = TotalAllRefCounts(prefsRef, allKeys);				if (startCount != endCount) {			CFIndex keyCount;			CFIndex keyIndex;						fprintf(stderr, "••• Leaked %ld reference counts.\n", endCount - startCount);			keyCount = CFArrayGetCount(allKeys);			for (keyIndex = 0; keyIndex < keyCount; keyIndex++) {				CFPropertyListRef thisPref;				// The commented out code is only needed when you're actively 				// trying to track down a leak.  Given that leaks are rare 				// I decided against making a proper architecture for this. 				// Just uncomment the code and modify it appropriately.								startCount = 0;				thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));	// C++ requires cast				CFQPropertyListDeepApplyFunction(thisPref, RefCounter, (void *) &startCount );//				if (keyIndex == 0) {//					fprintf(stderr, "*** BEFORE ***\n");//					PrintPropertyList(thisPref);//				}				tester();				endCount = 0;				thisPref = SCPreferencesGetValue(prefsRef, (CFStringRef) CFArrayGetValueAtIndex(allKeys, keyIndex));	// C++ requires cast				CFQPropertyListDeepApplyFunction(thisPref, RefCounter, (void *) &endCount );//				if (keyIndex == 0) {//					fprintf(stderr, "*** AFTER ***\n");//					PrintPropertyList(thisPref);//				}								if (startCount != endCount) {					fprintf(stderr, "••• Leaked %ld reference counts in set number %ld\n", endCount - startCount, keyIndex);					CFShow(CFArrayGetValueAtIndex(allKeys, keyIndex));				}			}		}	}	MoreSCClose(&err, false);	CFQRelease(allKeys);    if (err != noErr) {        fprintf(stderr, "••• Failed with error %ld!\n", err);    }	gRunSilent = false;}/////////////////////////////////////////////////////////////////#pragma mark ***** Debugging// This code is for debugging individual modules and hasn't been integrated // into a formal test yet.#if 0	static void DebugModemScriptSearch(void)		// Used for debugging the modem script code.	{		OSStatus 	err;		CFArrayRef	cclArray;		CFIndex		indexOfDefaultCCL;				cclArray = nil;		err = MoreSCCreateCCLArray(&cclArray, &indexOfDefaultCCL);		if (err == noErr) {			CFIndex i;			CFIndex c;						c = CFArrayGetCount(cclArray);			fprintf(stderr, "CCL Count = %ld\n", c);			for (i = 0; i < c; i++) {				fprintf(stderr, "%3ld %c ", i, i == indexOfDefaultCCL ? '*' : ' ');				CFShow(CFArrayGetValueAtIndex(cclArray, i));			}		}				CFQRelease(cclArray);			    if (err == noErr) {    	    fprintf(stderr, "Success!\n");	    } else {    	    fprintf(stderr, "••• Failed with error %ld!\n", err);	    }	}#endif#if 0	static void DebugCreateProxiesEntity(void)		// Used for debugging MoreSCCreateProxiesEntity.	{		OSStatus 			err;		MoreSCProxiesDigest proxy;		CFDictionaryRef     entity;				BlockZero(&proxy, sizeof(proxy));		entity = nil;		err = MoreSCCreateProxiesEntity(&proxy, &entity);		if (err == noErr) {			PrintPropertyList(entity);		}		CFQRelease(entity);	}#endif#if 0	static void DebugOpenClose(void)		// Used for debugging MoreSCOpen/Close.	{		OSStatus 	err;		int_t 		oldUID;				// Simple open/close.		err = MoreSCOpen(false, false);		MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 1) failed with error %ld!\n", err);	    }	    	    // Open and close dirty.	    	    err = MoreSCOpen(false, false);	    MoreSCClose(&err, true);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 2) failed with error %ld!\n", err);	    }			    // Open locked and close not dirty.	    	    err = MoreSCOpen(true, true);	    MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 3) failed with error %ld!\n", err);	    }			    // Open locked and close dirty.	    	    err = MoreSCOpen(true, true);	    MoreSCClose(&err, true);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 4) failed with error %ld!\n", err);	    }				// Simple recursive open with no privileges needed.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = MoreSCOpen(false, false);						MoreSCClose(&err, false);		}		MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 5) failed with error %ld!\n", err);	    }				// Recursive open with no lock but dirty made.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = MoreSCOpen(false, false);						MoreSCClose(&err, false);		}		MoreSCClose(&err, true);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 6) failed with error %ld!\n", err);	    }				// Recursive open with lock and no dirty.				err = MoreSCOpen(true, true);		if (err == noErr) {			err = MoreSCOpen(false, false);						MoreSCClose(&err, false);		}		MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 7) failed with error %ld!\n", err);	    }		// Recursive open with lock and dirty.				err = MoreSCOpen(true, true);		if (err == noErr) {			err = MoreSCOpen(false, false);						MoreSCClose(&err, false);		}		MoreSCClose(&err, true);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 8) failed with error %ld!\n", err);	    }				// Recursive open with inner no lock and dirty.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = MoreSCOpen(false, false);						MoreSCClose(&err, true);		}		MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 9) failed with error %ld!\n", err);	    }				// Recursive open with inner lock and no dirty.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = MoreSCOpen(true, true);						MoreSCClose(&err, false);		}		MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 10) failed with error %ld!\n", err);	    }		// Recursive open with inner lock and dirty.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = MoreSCOpen(true, true);						MoreSCClose(&err, true);		}		MoreSCClose(&err, false);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 11) failed with error %ld!\n", err);	    }				// Recursive open with both inner and outer lock and dirty.				err = MoreSCOpen(true, true);		if (err == noErr) {			err = MoreSCOpen(true, true);						MoreSCClose(&err, true);		}		MoreSCClose(&err, true);	    if (err != noErr) {	        fprintf(stderr, "••• DebugOpenClose (step 12) failed with error %ld!\n", err);	    }		// Open/close with error.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = -1;		}		MoreSCClose(&err, false);	    if (err != -1) {	        fprintf(stderr, "••• DebugOpenClose (step 13) failed with error %ld!\n", err);	    }		// Open/close with dirty and error.				err = MoreSCOpen(false, false);		if (err == noErr) {			err = -1;		}		MoreSCClose(&err, true);	    if (err != -1) {	        fprintf(stderr, "••• DebugOpenClose (step 14) failed with error %ld!\n", err);	    }				// Open/close with lock, dirty and error.				err = MoreSCOpen(true, true);		if (err == noErr) {			err = -1;		}		MoreSCClose(&err, true);	    if (err != -1) {	        fprintf(stderr, "••• DebugOpenClose (step 15) failed with error %ld!\n", err);	    }				// Switch to the nobody user.				oldUID = seteuid(-2);		// Lock but no dirty, should trigger error on the open.				err = MoreSCOpen(true, true);		MoreAssertQ(err == kSCStatusAccessError);		MoreSCClose(&err, false);	    if (err != kSCStatusAccessError) {	        fprintf(stderr, "••• DebugOpenClose (step 16) failed with error %ld!\n", err);	    }		// No lock but dirty, should trigger error on the close.				err = MoreSCOpen(false, false);		MoreAssertQ(err == noErr);		MoreSCClose(&err, true);	    if (err != kSCStatusAccessError) {	        fprintf(stderr, "••• DebugOpenClose (step 16) failed with error %ld!\n", err);	    }				(void) seteuid(oldUID);	}#endifint main(int argc, char *argv[]){	#pragma unused(argc)	#pragma unused(argv)    fprintf(stderr, "Hello Cruel World!\n");        if ( geteuid() != 0 ) {    	printf("••• MoreSCFTest won't run properly unless it's run as root.\n");    }	#if 0		DebugModemScriptSearch();		DebugCreateProxiesEntity();		DebugOpenClose();	#endif		#if 0		TestPortScanner();		TestCopySetsDict();		TestSetEnumerationAndSwitch();		TestDuplicateAndDeleteSet();		TestRenameSet();		TestServiceEnumerate();		TestDuplicateAndDeleteService();		TestRenameService();		TestEnumerateEntities();		TestCreateSet();		TestISP();		TestAppleTalk();	#endif	#if 1		LeakTest("TestPortScannertsDict", TestPortScanner);		LeakTest("TestCopySetsDict", TestCopySetsDict);		LeakTest("TestSetEnumerationAndSwitch", TestSetEnumerationAndSwitch);		LeakTest("TestDuplicateAndDeleteSet", TestDuplicateAndDeleteSet);		LeakTest("TestRenameSet", TestRenameSet);		LeakTest("TestServiceEnumerate", TestServiceEnumerate);		LeakTest("TestDuplicateAndDeleteService", TestDuplicateAndDeleteService);		LeakTest("TestRenameService", TestRenameService);		LeakTest("TestEnumerateEntities", TestEnumerateEntities);		LeakTest("TestCreateSet", TestCreateSet);		LeakTest("TestISP", TestISP);		LeakTest("TestAppleTalk", TestAppleTalk);	#endif    return 0;}